# Me List PWA Implementation Plan

## Overview

This plan transforms the Me List Wishlist application into a full Progressive Web App (PWA) with offline support, push notifications, and background sync capabilities.

**Total Estimated Time:** 8-12 hours across all stages

---

## ðŸ“‹ Prerequisites Checklist

Before starting, ensure:
- [ ] App is deployed to HTTPS (Vercel âœ“)
- [ ] Supabase backend is configured
- [ ] You have access to create Supabase Edge Functions (for push notifications)
- [ ] App logo available in high resolution

---

# ðŸŸ¢ STAGE 1: Basic PWA Foundation

**Goal:** Make the app installable with basic asset caching  
**Estimated Time:** 30-45 minutes  
**Difficulty:** Easy

## Phase 1.1: Install Dependencies & Configure Vite

### Tasks:
1. Install `vite-plugin-pwa` and `workbox-window`
2. Update `vite.config.ts` with PWA plugin configuration
3. Configure manifest settings (app name, theme colors, display mode)

### Files to Create/Modify:
- `vite.config.ts` - Add PWA plugin configuration
- `public/manifest.json` - Will be auto-generated by plugin

---

## Phase 1.2: Generate PWA Icons

### Tasks:
1. Generate required icon sizes from existing logo:
   - `pwa-192x192.png` - Standard icon
   - `pwa-512x512.png` - Splash screen icon
   - `pwa-maskable-512x512.png` - Maskable icon for Android
   - `apple-touch-icon.png` - iOS home screen icon (180x180)
2. Place icons in `/public` directory

### Files to Create:
- `public/pwa-192x192.png`
- `public/pwa-512x512.png`
- `public/pwa-maskable-512x512.png`
- `public/apple-touch-icon.png`

---

## Phase 1.3: Update HTML Meta Tags

### Tasks:
1. Add `theme-color` meta tag
2. Add `apple-mobile-web-app` meta tags for iOS support
3. Link to manifest file
4. Add favicon references

### Files to Modify:
- `index.html`

---

## Phase 1.4: Create Offline Fallback Page

### Tasks:
1. Create a simple offline fallback HTML page
2. Style it to match the app's design
3. Configure service worker to serve it when offline

### Files to Create:
- `public/offline.html`

---

## ðŸ§ª STAGE 1 TEST CHECKPOINT

### Manual Testing:
1. [ ] Run `npm run build` and `npm run preview`
2. [ ] Open Chrome DevTools â†’ Application â†’ Manifest
   - Verify manifest loads correctly
   - Check all icons are present
3. [ ] Application â†’ Service Workers
   - Verify service worker is registered
4. [ ] Click "Install" prompt in address bar
   - App should install to desktop/home screen
5. [ ] Open installed app
   - Should open in standalone mode (no browser chrome)
6. [ ] Disconnect network (DevTools â†’ Network â†’ Offline)
   - Should see offline fallback page

### Success Criteria:
- âœ… App is installable
- âœ… Manifest shows correct name, colors, icons
- âœ… Service worker is active
- âœ… Offline fallback page appears when disconnected

---

## ðŸ”„ CONTINUE PROMPT FOR STAGE 2:
```
"Continue with Stage 2: Implement full offline support for the Me List PWA. 
Cache the app shell, API responses, and enable viewing wishlists offline."
```

---

# ðŸŸ¡ STAGE 2: Offline Support

**Goal:** Enable viewing wishlists and user data while offline  
**Estimated Time:** 2-3 hours  
**Difficulty:** Medium

## Phase 2.1: Configure Workbox Caching Strategies

### Tasks:
1. Set up runtime caching for different resource types:
   - **App Shell** (HTML, CSS, JS): Cache-first strategy
   - **Images**: Cache-first with 30-day expiration
   - **API calls**: Network-first with cache fallback
   - **Fonts**: Cache-first (long-lived)
2. Configure cache size limits to prevent storage bloat

### Caching Strategy Reference:
| Resource Type | Strategy | Rationale |
|--------------|----------|-----------|
| Static assets | CacheFirst | Rarely change, fast loading |
| API data | NetworkFirst | Fresh when possible, cached fallback |
| Images | CacheFirst + Expiration | Balance freshness vs performance |
| User-specific data | StaleWhileRevalidate | Show cached, update in background |

### Files to Modify:
- `vite.config.ts` - Add runtimeCaching configuration

---

## Phase 2.2: Implement IndexedDB for Offline Data

### Tasks:
1. Create an IndexedDB wrapper utility for offline storage
2. Store wishlist data locally when fetched
3. Store user profile and friends data
4. Implement data versioning for schema changes

### Files to Create:
- `src/lib/offlineStorage.ts` - IndexedDB wrapper
- `src/hooks/useOfflineData.ts` - Hook for offline-aware data fetching

---

## Phase 2.3: Create Offline-Aware React Query Configuration

### Tasks:
1. Configure React Query for offline support
2. Set up query persistence with IndexedDB
3. Create offline-aware fetch wrapper
4. Handle stale data indicators in UI

### Files to Create/Modify:
- `src/lib/queryClient.ts` - Enhanced query client configuration
- `src/hooks/useOfflineStatus.ts` - Network status hook

---

## Phase 2.4: Add Offline UI Indicators

### Tasks:
1. Create offline banner component
2. Show sync status indicators
3. Disable actions that require network (with clear messaging)
4. Queue actions for later sync (preparation for Stage 4)

### Files to Create:
- `src/components/OfflineBanner.tsx`
- `src/components/SyncIndicator.tsx`

### Files to Modify:
- `src/App.tsx` - Add offline banner
- UI components - Add offline state handling

---

## ðŸ§ª STAGE 2 TEST CHECKPOINT

### Manual Testing:
1. [ ] Load app online, navigate to your wishlists
2. [ ] Go offline (DevTools â†’ Network â†’ Offline)
3. [ ] Refresh the page
   - App should load from cache
   - Wishlists should display from IndexedDB
4. [ ] Verify offline banner appears
5. [ ] Try to perform an action (e.g., add item)
   - Should show appropriate offline messaging
6. [ ] Go back online
   - Offline banner should disappear
   - Fresh data should load

### Success Criteria:
- âœ… App loads completely offline after first visit
- âœ… Wishlists viewable offline
- âœ… Clear offline status indication
- âœ… Graceful degradation of features

---

## ðŸ”„ CONTINUE PROMPT FOR STAGE 3:
```
"Continue with Stage 3: Implement push notifications for the Me List PWA.
Set up Web Push API, Supabase Edge Functions for sending notifications,
and notification preferences UI."
```

---

# ðŸŸ  STAGE 3: Push Notifications

**Goal:** Notify users when someone claims an item, adds them as a friend, etc.  
**Estimated Time:** 3-4 hours  
**Difficulty:** Medium-Hard

## Phase 3.1: Set Up VAPID Keys & Backend

### Tasks:
1. Generate VAPID keys for Web Push
2. Store public key in environment variables
3. Create Supabase table for push subscriptions
4. Set up RLS policies for subscription data

### Database Schema:
```sql
CREATE TABLE push_subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  endpoint TEXT NOT NULL,
  p256dh TEXT NOT NULL,
  auth TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(user_id, endpoint)
);
```

### Files to Create:
- `supabase/migrations/xxx_push_subscriptions.sql`
- `.env` updates for VAPID keys

---

## Phase 3.2: Implement Push Subscription in Frontend

### Tasks:
1. Create push notification permission request flow
2. Subscribe to push notifications via service worker
3. Send subscription to Supabase
4. Handle subscription updates/unsubscribe

### Files to Create:
- `src/lib/pushNotifications.ts` - Push subscription utilities
- `src/hooks/usePushNotifications.ts` - Push notification hook

---

## Phase 3.3: Create Notification Preferences UI

### Tasks:
1. Add notification settings to user profile/settings page
2. Allow granular control over notification types:
   - Item claimed notifications
   - Friend request notifications
   - Wishlist shared with you
   - Weekly digest
3. Store preferences in user profile

### Files to Create:
- `src/components/NotificationSettings.tsx`

### Files to Modify:
- Settings/Profile page

---

## Phase 3.4: Create Supabase Edge Function for Sending Notifications

### Tasks:
1. Create Edge Function that sends Web Push notifications
2. Integrate with Supabase Database Webhooks:
   - Trigger on item claim
   - Trigger on friend request
   - Trigger on wishlist share
3. Handle notification payload formatting
4. Handle expired subscriptions cleanup

### Files to Create:
- `supabase/functions/send-push-notification/index.ts`

---

## Phase 3.5: Handle Notification Display & Actions

### Tasks:
1. Configure service worker to display notifications
2. Add notification click handlers (open relevant page)
3. Add notification action buttons where appropriate
4. Handle notification when app is open vs closed

### Files to Modify:
- Service worker configuration in `vite.config.ts`

---

## ðŸ§ª STAGE 3 TEST CHECKPOINT

### Manual Testing:
1. [ ] Enable notifications in app settings
   - Browser should prompt for permission
2. [ ] Accept notification permission
   - Subscription should be saved to Supabase
3. [ ] Have another user claim one of your items
   - Should receive push notification
4. [ ] Click notification
   - Should open app to relevant page
5. [ ] Disable notifications in app
   - Should unsubscribe successfully
6. [ ] Test with app closed completely
   - Notifications should still arrive

### Success Criteria:
- âœ… Permission flow works smoothly
- âœ… Subscriptions stored correctly
- âœ… Notifications received for relevant events
- âœ… Notification clicks navigate correctly
- âœ… Preferences respected

---

## ðŸ”„ CONTINUE PROMPT FOR STAGE 4:
```
"Continue with Stage 4: Implement background sync for the Me List PWA.
Enable queueing actions while offline and syncing when connection returns."
```

---

# ðŸ”´ STAGE 4: Background Sync

**Goal:** Queue actions taken offline and sync when connection returns  
**Estimated Time:** 2-3 hours  
**Difficulty:** Hard

## Phase 4.1: Set Up Background Sync API

### Tasks:
1. Register for background sync in service worker
2. Create sync event handlers
3. Handle sync failures and retries

### Files to Modify:
- Service worker configuration

---

## Phase 4.2: Create Offline Action Queue

### Tasks:
1. Create IndexedDB store for pending actions
2. Implement action queuing system:
   - Add item to wishlist
   - Edit item
   - Delete item
   - Claim/unclaim item
   - Accept/reject friend request
3. Store action metadata (timestamp, type, data)

### Files to Create:
- `src/lib/syncQueue.ts` - Sync queue management
- `src/lib/offlineActions.ts` - Offline action handlers

---

## Phase 4.3: Implement Optimistic Updates

### Tasks:
1. Update UI immediately when action is queued
2. Show pending sync indicator on affected items
3. Handle sync conflicts (e.g., item deleted by someone else)
4. Rollback UI on sync failure

### Files to Create:
- `src/hooks/useOptimisticMutation.ts`

### Files to Modify:
- Wishlist item components
- Action handlers throughout app

---

## Phase 4.4: Create Sync Status UI

### Tasks:
1. Show number of pending syncs
2. Show sync in progress indicator
3. Show sync errors with retry option
4. Allow manual sync trigger

### Files to Create:
- `src/components/SyncStatus.tsx`

### Files to Modify:
- App layout/header

---

## Phase 4.5: Handle Sync Conflicts

### Tasks:
1. Implement conflict detection
2. Create conflict resolution UI
3. Strategies:
   - Last-write-wins for simple conflicts
   - User choice for complex conflicts
4. Log conflicts for debugging

### Files to Create:
- `src/lib/conflictResolution.ts`
- `src/components/ConflictDialog.tsx`

---

## ðŸ§ª STAGE 4 TEST CHECKPOINT

### Manual Testing:
1. [ ] Go offline
2. [ ] Add a new item to wishlist
   - Should show as pending with sync indicator
3. [ ] Edit an existing item
4. [ ] Go back online
   - Items should sync automatically
   - Sync indicators should clear
5. [ ] Test conflict scenario:
   - Go offline
   - Edit item
   - Have another user edit same item
   - Go online
   - Should detect and handle conflict
6. [ ] Test sync failure:
   - Queue action offline
   - Simulate API failure
   - Should show error with retry option

### Success Criteria:
- âœ… Actions queued while offline
- âœ… Automatic sync on reconnection
- âœ… Optimistic updates work correctly
- âœ… Conflicts detected and handled
- âœ… Failures handled gracefully with retry

---

# ðŸ“‹ FINAL CHECKLIST

## Production Readiness:
- [ ] All stages tested on multiple browsers (Chrome, Safari, Firefox, Edge)
- [ ] Tested on mobile devices (iOS Safari, Android Chrome)
- [ ] Service worker updates gracefully
- [ ] Cache invalidation works correctly
- [ ] Push notification payloads don't contain sensitive data
- [ ] Background sync doesn't drain battery excessively
- [ ] Analytics tracking for PWA installs and usage

## Performance Metrics:
- [ ] Lighthouse PWA score â‰¥ 90
- [ ] First Contentful Paint < 2s
- [ ] Offline load time < 1s
- [ ] Service worker doesn't block main thread

## Documentation:
- [ ] Update README with PWA features
- [ ] Document notification types
- [ ] Document offline capabilities for users
- [ ] Create troubleshooting guide

---

# ðŸš€ Quick Start - Stage 1 Prompt:
```
"Let's start implementing Stage 1 of the PWA plan: Basic PWA Foundation.
Begin with Phase 1.1 - Install vite-plugin-pwa and configure the Vite config
with manifest settings for the Me List app."
```

---

## Appendix: Technology Reference

### Libraries Used:
- `vite-plugin-pwa` - PWA integration for Vite
- `workbox-window` - Service worker utilities
- `idb` - IndexedDB wrapper (optional, can use native)
- `web-push` - VAPID key generation (backend)

### Browser Support:
| Feature | Chrome | Safari | Firefox | Edge |
|---------|--------|--------|---------|------|
| Install | âœ… | âœ… (iOS 16.4+) | âœ… | âœ… |
| Offline | âœ… | âœ… | âœ… | âœ… |
| Push | âœ… | âœ… (macOS only) | âœ… | âœ… |
| Background Sync | âœ… | âŒ | âŒ | âœ… |

### Fallback Strategy for Limited Support:
- Safari/Firefox: Poll for updates when app is open
- iOS: Prompt users to check app periodically
